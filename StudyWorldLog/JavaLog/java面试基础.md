## . java面试基础
***
### Java基础之简述题
***1. &和&&的区别:***<br/>
** 简要说明 ** <br/>
按位与：a&b是把a和b都转换成二进制数然后再进行与的运算；<br/>
逻辑与：a&&b就是当且仅当两个操作数均为 true时，其结果才为 true；只要有一个为零，a&&b就为零。<br/>
&对每一个都判断；
&&只要前面是false就输出false，而不继续判断后面了<br/>
**详细说明：**<br/>
有关&和&&的详细解释如下：<br/>
&，此双目运算符：将两个表达式的值按二进制位展开，对应的位(bit)按值进行“与”运算，结果保留在该位上…<br/>
比如170&204
对应二进制就是<br/>
10101010B <br/>
&11001100B <br/>
=10001000B…<br/>
170&204=136…
该位只要有一个值为0结果为0，否则结果为1。<br/>
如果两数位数不同，则较短数高位补零，再运算，比如char a=100;int b=260;
a&b实际是0000 0000 0110 0100&0000 0001 0000 0100.其结果为int型0000 0000 000 0100即4…<br/>
&&:此双目运算符，计算两个表达式同时成立的“真值”（同时成立真值为真否则为假）<br/>
逻辑真值有两种，1为真，0为假，但在运算时用非零表示真，0表示假…
即：数值->逻辑真值－－非0为真，0为假/逻辑真值->数值－－真为1，假为0…<br/>
例如：char a=1,b=0,c=-1;那么a真b假c真。a&&b和c&&b为假值为0，a&&c为真值为1

***2. Get和Post的区别:***<br/>
** 普遍答案：**
*  GET使用URL或Cookie传参。而POST将数据放在BODY中。
*  GET的URL会有长度上的限制，则POST的数据则可以非常大。
*  POST比GET安全，因为数据在地址栏上不可见。

**真相是：**
*  GET和POST与数据如何传递没有关系
　　GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data(URL, Body, Header)是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。
　　HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。只是HTML标准里面建议这样做，建议不意味着二者区别。
* HTTP协议对GET和POST都没有对长度的限制
　　HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成：
　　1. 浏览器。据说早期的浏览器会对URL长度做限制，现在已经不是。
　　2. 服务器。会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。
* 安全不安全和GET、POST没有关系，只是相对而言。

***2. http response code:***

----
1×× 　　保留   
2×× 　　表示请求成功地接收   
3×× 　　为完成请求客户需进一步细化请求   
4×× 　　客户错误   
5×× 　　服务器错误  

------

***3. udp连接和TCP的不同之处:***

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接

2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付

3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的
UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）

4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信

5、TCP首部开销20字节;UDP的首部开销小，只有8个字节,TCP可以控制通信流量的浪费,UDP不可以，一般UDP只提供作为传输层协议的最基本功能,将部分控制转移到应用程序去处理.不用管数据包是不是到达或者乱序。

6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道

***3. 简介java中的soft reference:***

Java中的SoftReference

软引用技术的引进使Java应用可以更好的管理内存，稳定系统，防止系统内存溢出，避免系统崩溃。因此在处理一些占用内存大而且声明周期较长，但使用并不频繁的对象时应尽量应用该技术。但事物总带有两面性的，有利也有弊，在某些时候对软引用的使用会降低应用的运行效率与性能，例如：应用软引用的对象的初始化过程较为耗时，或者对象的状态在程序的运行过程中发生了变化，都会给重新创建对象与初始化对象带来不同程度的麻烦，有些时候我们要权衡利弊择时应用。

即对象的软引用。如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。使用软引用能防止内存泄露，增强程序的健壮性。

SoftReference的特点是它的一个实例保存对一个Java对象的软引用，该软引用的存在不妨碍垃圾收集线程对该Java对象的回收。也就是说，一旦SoftReference保存了对一个Java对象的软引用后，在垃圾线程对这个Java对象回收前，SoftReference类所提供的get()方法返回Java对象的强引用。另外，一旦垃圾线程回收该Java对象之后，get()方法将返回null


***4. 抽象类和接口的区别:***

* 抽象类就是为了继承而存在的，如果你定义了一个抽象类，却不去继承它，那么等于白白创建了这个抽象类，因为你不能用它来做任何事情。对于一个父类，如果它的某个方法在父类中实现出来没有任何意义，必须根据子类的实际需求来进行不同的实现，那么就可以将这个方法声明为abstract方法，此时这个类也就成为abstract类了。

* 允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。

**区别：**
1.语法层面上的区别

　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；

　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；

　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；

　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。

2.设计层面上的区别

1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。

2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。


***5. Overload和Override的区别:***

**override（重写，覆盖）**

1、方法名、参数、返回值相同。

2、子类方法不能缩小父类方法的访问权限。

3、子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。
4、存在于父类和子类之间。

5、方法被定义为final不能被重写。

**overload（重载，过载） **

1、参数类型、个数、顺序至少有一个不相同。

2、不能重载只有返回值不同的方法名。

3、存在于父类和子类、同类中。

***6. Static Nested Class 和 Inner Class的不同:***

Nested Class 一般是C++的说法，Inner Class 一般是JAVA的说法。

Nested class分为静态Static nested class 的和非静态的 inner class,

静态的Static nested class是不可以直接调用它的外部类enclosing class的，但是可以通过外部类的引用来调用，就像你在一个类中写了main方法一样。

非静态类inner class 可以自由的引用外部类的属性和方法，但是它与一个实例绑定在了一起，不可以定义静态的属性、方法 。

***7. 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concreteclass)?:***

接口可以继承接口。抽象类可以实现(implements)接口，抽象类是否可继承实
体类，但前提是实体类必须有明确的构造函数。

**8.private和default有什么区别**

注意：Java的访问控制是停留在编译层的，也就是它不会在.class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。其实，通过反射的手段，是可以访问任何包下任何类中的成员，例如，访问类的私有成员也是可能的。
区别：

（1）public：可以被所有其他类所访问。

（2）private：只能被自己访问和修改。

（3）protected：自身，子类及同一个包中类可以访问。

（4）default（默认）：同一包中的类可以访问，声明时没有加修饰符，认为是friendly。

**9.String s=new String(“abc”); new了几个对象**

两个对象。

说到这里，我们就需要引入对字符串池相关知识的回顾了。  

在JAVA虚拟机（JVM）中存在着一个字符串池，其中保存着很多String对象，并且可以被共享使用，因此它提高了效率。由于String类是final的，它的值一经创建就不可改变，因此我们不用担心String对象共享而带来程序的混乱。字符串池由String类维护，我们可以调用intern()方法来访问字符串池。  

我们再回头看看Stringa="abc";，这行代码被执行的时候，JAVA虚拟机首先在字符串池中查找是否已经存在了值为"abc"的这么一个对象，它的判断依据是String类equals(Object obj)方法的返回值。如果有，则不再创建新的对象，直接返回已存在对象的引用；如果没有，则先创建这个对象，然后把它加入到字符串池中，再将它的引用返回。因此，我们不难理解前面三个例子中头两个例子为什么是这个答案了。

只有使用引号包含文本的方式创建的String对象之间使用“+”连接产生的新对象才会被加入字符串池中。对于所有包含new方式新建对象（包括null）的“+”连接表达式，它所产生的新对象都不会被加入字符串池中，对此我们不再赘述。因此我们提倡大家用引号包含文本的方式来创建String对象以提高效率，实际上这也是我们在编程中常采用的。
**小提示：**

栈（stack）：主要保存基本类型（或者叫内置类型）（char、byte、short、int、long、float、double、boolean）和对象的引用，数据可以共享，速度仅次于寄存器（register），快于堆。

堆（heap）：用于存储对象

堆区：主要存放Java程序运行时创建的所有引用类型(new()生成的对象)都放在其中；

栈区：主要存放Java程序运行时所需的局部变量、方法的参数、对象的引用以及中间运算结果等数据；

代码区：主要存放Java的代码；

数据区：主要存放静态变量及全局变量

**10.启动一个线程是用run()还是start()?**

用start方法来启动线程，真正实现了多线程运行，这时无需等待run方法体代码执行完毕而直接继续执行下面的代码。通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到spu时间片，就开始执行run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。

总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。

**11.多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?**

多线程有三种实现方法。一种是继承Thread类，一种是实现Runnable接口，一种是实现Callable接口。  

同步有两种方法。一种同步方法，一种同步代码！分别是synchronized,wait与notify

**12.sleep和wait有什么区别？？**
 一个是用来让线程休息，一个是用来挂起线程

**13.Socket编程的步骤**
Socket通信的步骤

① 创建ServerSocket和Socket

② 打开连接到Socket的输入/输出流

③ 按照协议对Socket进行读/写操作

④ 关闭输入输出流、关闭Socket

**14.ArrayList和Vector区别，HashMap和HashTable区别**

就ArrayList与Vector主要从二方面来说.
一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的

二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半
就HashMap与HashTable主要从三方面来说。
一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现

二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的

三.值：只有HashMap可以让你将空值作为一个表的条目的key或value
Collection
├List
│├LinkedList
│├ArrayList
│└Vector
│　└Stack
└Set
Map
├Hashtable
├HashMap
└WeakHashMap

Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）
Map提供key到value的映

**15.ArrayList和LinkedList的区别**

ArrayList和LinkedList的大致区别：

1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。

2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。

3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。

**16.List, Set, Map是否继承自Collection接口?**

List，Set是，Map不是。

如图：
     Collection
　　├List
　　│├LinkedList
　　│├ArrayList
　　│└Vector
　　│　└Stack
　　└Set

　　Map
　　├Hashtable
　　├HashMap
　　└WeakHashMap

Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java JDK不能提供直接继承自Collection的类，Java JDK提供的类都是继承自Collection的"子接口"，如:List和Set。

注意：Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当做一组key集合，一组value集合，或者一组key-value映射。

**17.hashCode方法的作用**

hashCode方法的主要作用是为了配合基于散列的集合一起正常运行，这样的散列集合包括HashSet、HashMap以及HashTable。

可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。

也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；

如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；

如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；

如果两个对象的hashcode值相等，则equals方法得到的结果未知。

**18.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?**

应该从它俩的区别谈起，==是用来判断两者是否是同一对象（同一事物），而equals是用来判断是否引用同一个对象。再看一下Set里面存的是

对象，还是对象的引用。根据java的存储机制可知，set里面存放的是对象的引用，所以当两个元素只要满足了equals()时就已经指向同一个对象，

也就出现了重复元素。所以应该用equals()来判断。

**19.heap和stack有什么区别**

"Java 的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。"

“栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。 ”
